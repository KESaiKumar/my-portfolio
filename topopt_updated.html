<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Topology Optimization (Ultimate)</title>
    <meta name="description" content="Advanced TopOpt with Stress Analysis, Displacement Views, and Grid Visualization.">
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --text-color: #e2e8f0;
            --accent-color: #38bdf8;
            --danger-color: #ef4444;
            --success-color: #22c55e;
            --passive-color: #10b981;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
        }

        header {
            width: 100%;
            padding: 1rem;
            background-color: var(--panel-bg);
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.5rem; color: var(--accent-color); }
        p { margin: 0.5rem 0 0; font-size: 0.9rem; opacity: 0.8; }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            flex: 1;
            width: 100%;
            max-width: 1400px; /* Increased max-width */
            flex-wrap: wrap; /* Allow wrapping on medium screens */
        }

        @media (min-width: 900px) {
            .main-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
            }
            
            /* Order switching: Controls Left, Canvas Right on Desktop */
            .controls { order: 1; }
            .canvas-wrapper { order: 2; }
        }

        /* Canvas Area */
        .canvas-wrapper {
            position: relative;
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            cursor: crosshair;
            /* Default order for mobile */
            order: 1;
            flex-shrink: 0;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
        }

        .overlay-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        /* Controls Panel */
        .controls {
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            width: 100%;
            max-width: 340px; /* Slightly narrower to fit better */
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            max-height: 85vh;
            overflow-y: auto;
            /* Default order for mobile */
            order: 2;
            flex-shrink: 0;
        }

        /* Tool Palette */
        .tool-palette {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            background: #0f172a;
            padding: 10px;
            border-radius: 6px;
        }

        .tool-btn {
            padding: 8px;
            border: 2px solid transparent;
            background: #334155;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            text-align: center;
            transition: all 0.2s;
        }

        .tool-btn:hover { background: #475569; }
        
        .tool-btn.active {
            border-color: var(--accent-color);
            background: #1e293b;
            color: var(--accent-color);
            font-weight: bold;
        }

        .section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
            margin-bottom: 5px;
            border-bottom: 1px solid #334155;
            padding-bottom: 2px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        label {
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
        }

        select {
            background: #334155;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-color);
        }

        .button-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.75rem;
        }

        button.primary { background-color: var(--accent-color); color: #0f172a; }
        button.primary:hover { background-color: #7dd3fc; }

        button.danger { background-color: var(--danger-color); color: white; }
        button.danger:hover { background-color: #f87171; }

        button.secondary { background-color: #475569; color: white; }
        button.secondary:hover { background-color: #64748b; }

        .status-bar {
            padding: 8px;
            background: #0f172a;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.75rem;
            color: #22c55e;
            white-space: pre-wrap;
        }

        .legend-bar {
            height: 10px;
            width: 100%;
            background: linear-gradient(to right, blue, cyan, lime, yellow, red);
            border-radius: 2px;
            margin-top: 5px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #94a3b8;
        }
    </style>
</head>
<body>

<header>
    <h1>Topology Optimization Ultimate</h1>
    <p>Design • Analyze • Optimize</p>
</header>

<div class="main-container">
    
    <!-- Visualization (Order 2 on Desktop) -->
    <div class="canvas-wrapper">
        <canvas id="simCanvas"></canvas>
        <div class="overlay-info" id="overlayInfo">
            <span>Iter: 0</span>
            <span id="objValDisplay">C: 0.00</span>
        </div>
    </div>

    <!-- Controls (Order 1 on Desktop - LEFT SIDE) -->
    <div class="controls">
        
        <div>
            <div class="section-title">Analysis Mode</div>
            <select id="viewMode">
                <option value="density">Material Density</option>
                <option value="stress">Von Mises Stress</option>
                <option value="disp">Displacement Field</option>
            </select>
            <div id="stressLegend" style="display:none;">
                <div class="legend-bar"></div>
                <div class="legend-labels"><span>Low</span><span>High</span></div>
            </div>
            <div class="checkbox-group" style="margin-top: 10px;">
                <input type="checkbox" id="showGrid"> 
                <label for="showGrid" style="flex:1;">Show Grid Mesh</label>
            </div>
        </div>

        <div>
            <div class="section-title">Design Tools</div>
            <div class="tool-palette">
                <div class="tool-btn active" data-tool="force">Arrow (Force)</div>
                <div class="tool-btn" data-tool="fix">Anchor (Fix)</div>
                <div class="tool-btn" data-tool="passive_solid">Solid (Fixed)</div>
                <div class="tool-btn" data-tool="eraser">Eraser</div>
            </div>
            <div class="control-group" style="margin-top:8px;">
                <label>Force Mag: <span id="loadVal">1.0</span></label>
                <input type="range" id="forceMag" min="-5.0" max="5.0" step="0.5" value="1.0">
            </div>
        </div>

        <div>
            <div class="section-title">Optimization Goal</div>
            <select id="objMode">
                <option value="compliance">Max Stiffness (Min Compliance)</option>
                <option value="stress">Minimize Stress (FSD Heuristic)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Target Vol / Limit <span id="volVal">0.4</span></label>
            <input type="range" id="volFrac" min="0.1" max="0.9" step="0.05" value="0.4">
        </div>

        <div class="control-group">
            <label>Filter Radius <span id="filterVal">1.5</span></label>
            <input type="range" id="rmin" min="1.1" max="4.0" step="0.1" value="1.5">
        </div>

        <div class="status-bar" id="status">Select a tool to begin.</div>

        <div class="button-row">
            <button id="btnToggle" class="primary">Start</button>
            <button id="btnStep" class="secondary">Step</button>
        </div>
        <div class="button-row">
             <button id="btnReset" class="secondary">Reset</button>
             <button id="btnClearBC" class="danger">Clear All</button>
        </div>
    </div>
</div>

<script>
(function() {

// --- CONFIGURATION ---
const SCALE = 8; 
let NELX = 80;   
let NELY = 40;   

// --- STATE ---
let densities = [];       
let passive = [];         // 0=Design, 1=Solid(Non-Design)
let sensitivities = [];   
let fixedDofs = new Set(); 
let forceDofs = new Map(); 
let u_global = [];        // Store global displacement for visualization
let stress_global = [];   // Store element Von Mises stress

let running = false;
let iteration = 0;
let change = 1.0;
let compliance = 0;
let activeTool = 'force'; 
let viewMode = 'density'; // density, stress, disp
let objectiveMode = 'compliance'; // compliance, stress

// Solver Parameters
let volfrac = 0.4;
let penal = 3.0;
let rmin = 1.5;

// FE Constants
const E0 = 1.0;
const Emin = 1e-9;
const nu = 0.3;
let KE = new Float64Array(64);
// B Matrix and D Matrix for Stress Calculation (Plane Stress)
const D_mat = new Float64Array(9); // 3x3 Flattened

// UI Elements
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const overlayEl = document.getElementById('overlayInfo');
const objDisplay = document.getElementById('objValDisplay');
const legendEl = document.getElementById('stressLegend');

// --- INITIALIZATION ---

function init() {
    canvas.width = NELX * SCALE;
    canvas.height = NELY * SCALE;

    precomputeKE();
    precomputeStressMatrices();

    const n = NELX * NELY;
    densities = new Float64Array(n).fill(volfrac);
    passive = new Int8Array(n).fill(0); 
    sensitivities = new Float64Array(n).fill(0);
    stress_global = new Float64Array(n).fill(0);

    // Initialize u_global size
    u_global = new Float64Array(2 * (NELX + 1) * (NELY + 1)).fill(0);

    setupDefaultBC();
    draw();
}

function setupDefaultBC() {
    fixedDofs.clear();
    forceDofs.clear();
    // Cantilever
    for (let y = 0; y <= NELY; y++) {
        const n1 = y; 
        fixedDofs.add(2 * n1);     
        fixedDofs.add(2 * n1 + 1); 
    }
    const nodeBottomRight = (NELY + 1) * (NELX + 1) - 1; 
    forceDofs.set(2 * nodeBottomRight, -1.0); 
}

function precomputeKE() {
    // Plane Stress Element Stiffness
    const k = new Float64Array([
        1/2-nu/6, 1/8+nu/8, -1/4-nu/12, -1/8+3*nu/8, 
        -1/4+nu/12, -1/8-nu/8, nu/6, 1/8-3*nu/8
    ]);
    const KE_base = [
        [0, 1, 2, 3, 4, 5, 6, 7],
        [1, 0, 7, 6, 5, 4, 3, 2],
        [2, 7, 0, 5, 6, 3, 4, 1],
        [3, 6, 5, 0, 7, 2, 1, 4],
        [4, 5, 6, 7, 0, 1, 2, 3],
        [5, 4, 3, 2, 1, 0, 7, 6],
        [6, 3, 4, 1, 2, 7, 0, 5],
        [7, 2, 1, 4, 3, 6, 5, 0]
    ];
    for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
            KE[i * 8 + j] = (E0 / (1 - nu * nu)) * k[KE_base[i][j]];
        }
    }
}

function precomputeStressMatrices() {
    // Constitutive Matrix D for Plane Stress (3x3)
    const fac = E0 / (1 - nu*nu);
    D_mat[0] = fac * 1;
    D_mat[1] = fac * nu;
    D_mat[2] = 0;
    D_mat[3] = fac * nu;
    D_mat[4] = fac * 1;
    D_mat[5] = 0;
    D_mat[6] = 0;
    D_mat[7] = 0;
    D_mat[8] = fac * (1 - nu) / 2;
}

// --- FEA SOLVER (Conjugate Gradient) ---

function solveFE() {
    const totalDofs = 2 * (NELX + 1) * (NELY + 1);
    
    // Reuse global U to prevent drift, zeroing out ensures stability
    u_global.fill(0);
    
    let f = new Float64Array(totalDofs).fill(0);
    for (let [dof, val] of forceDofs) f[dof] = val;

    let r = new Float64Array(totalDofs);
    let p = new Float64Array(totalDofs);
    let Ap = new Float64Array(totalDofs);

    const freeDofs = [];
    for (let i = 0; i < totalDofs; i++) {
        if (!fixedDofs.has(i)) freeDofs.push(i);
        else r[i] = 0; // constrained
    }

    for(let i=0; i<totalDofs; i++) {
        if(!fixedDofs.has(i)) r[i] = f[i];
        p[i] = r[i];
    }

    let rsold = dotProduct(r, r, freeDofs);
    const maxIter = 1500;
    const tol = 1e-4;

    for (let iter = 0; iter < maxIter; iter++) {
        applyK(p, Ap);
        for (let dof of fixedDofs) Ap[dof] = 0;

        let alpha = rsold / dotProduct(p, Ap, freeDofs);
        for (let i of freeDofs) u_global[i] += alpha * p[i];
        for (let i of freeDofs) r[i] -= alpha * Ap[i];

        let rsnew = dotProduct(r, r, freeDofs);
        if (Math.sqrt(rsnew) < tol) break;

        let ratio = rsnew / rsold;
        for (let i of freeDofs) p[i] = r[i] + ratio * p[i];
        rsold = rsnew;
    }
    return u_global;
}

function dotProduct(a, b, indices) {
    let sum = 0;
    for (let i = 0; i < indices.length; i++) {
        let idx = indices[i];
        sum += a[idx] * b[idx];
    }
    return sum;
}

function applyK(u_in, out_vec) {
    out_vec.fill(0);
    for (let elx = 0; elx < NELX; elx++) {
        for (let ely = 0; ely < NELY; ely++) {
            const elIdx = elx * NELY + ely;
            const density = densities[elIdx]; 
            const scale = Math.pow(density, penal); 

            const n1 = (NELY + 1) * elx + ely;
            const n2 = (NELY + 1) * (elx + 1) + ely;
            const edof = [2*n1, 2*n1+1, 2*n2, 2*n2+1, 2*n2+2, 2*n2+3, 2*n1+2, 2*n1+3];

            const u_local = new Float64Array(8);
            for(let i=0; i<8; i++) u_local[i] = u_in[edof[i]];

            for(let i=0; i<8; i++) {
                let val = 0;
                for(let j=0; j<8; j++) val += KE[i*8 + j] * u_local[j];
                out_vec[edof[i]] += scale * val;
            }
        }
    }
}

// --- STRESS CALCULATION ---
function calculateStress(u) {
    let maxStress = 0;

    for (let elx = 0; elx < NELX; elx++) {
        for (let ely = 0; ely < NELY; ely++) {
            const elIdx = elx * NELY + ely;
            
            const n1 = (NELY + 1) * elx + ely;
            const n2 = (NELY + 1) * (elx + 1) + ely;
            const edof = [2*n1, 2*n1+1, 2*n2, 2*n2+1, 2*n2+2, 2*n2+3, 2*n1+2, 2*n1+3];
            
            const ue = new Float64Array(8);
            for(let k=0; k<8; k++) ue[k] = u[edof[k]];

            // Strain e = B * u (Approximate at centroid)
            const ex = 0.5 * (-ue[0] + ue[2] + ue[4] - ue[6]);
            const ey = 0.5 * (-ue[1] - ue[3] + ue[5] + ue[7]);
            const gxy = 0.5 * (-ue[0] - ue[1] - ue[2] + ue[3] + ue[4] + ue[5] + ue[6] - ue[7]);

            // Stress s = D * e
            const sx = D_mat[0]*ex + D_mat[1]*ey; 
            const sy = D_mat[3]*ex + D_mat[4]*ey;
            const txy = D_mat[8]*gxy;

            // Von Mises
            const vm = Math.sqrt(sx*sx - sx*sy + sy*sy + 3*txy*txy);
            
            // Weight by density for visualization/optimization stability
            // For Optimization (FSD), we want physical stress.
            // For visualization, we dampen void stress.
            // Let's store damped stress in global array for simplicity.
            const dens = densities[elIdx];
            const visualStress = vm * Math.pow(dens, penal);

            stress_global[elIdx] = visualStress;
            if(visualStress > maxStress) maxStress = visualStress;
        }
    }
    return maxStress;
}

// --- OPTIMIZER ---

function optimizeStep() {
    const u = solveFE();
    
    // Always calculate stress if mode is stress OR if viewing stress
    if (objectiveMode === 'stress' || viewMode === 'stress') {
        calculateStress(u);
    }

    compliance = 0;

    // 1. Calculate Sensitivities
    for (let elx = 0; elx < NELX; elx++) {
        for (let ely = 0; ely < NELY; ely++) {
            const elIdx = elx * NELY + ely;
            const dens = densities[elIdx];

            if (objectiveMode === 'compliance') {
                // Min Compliance Sensitivity
                const n1 = (NELY + 1) * elx + ely;
                const n2 = (NELY + 1) * (elx + 1) + ely;
                const edof = [2*n1, 2*n1+1, 2*n2, 2*n2+1, 2*n2+2, 2*n2+3, 2*n1+2, 2*n1+3];

                let ue = new Float64Array(8);
                for(let k=0; k<8; k++) ue[k] = u[edof[k]];

                let strainEnergy = 0;
                for(let i=0; i<8; i++){
                    let rowVal = 0;
                    for(let j=0; j<8; j++) rowVal += KE[i*8+j] * ue[j];
                    strainEnergy += ue[i] * rowVal;
                }
                compliance += Math.pow(dens, penal) * strainEnergy;
                sensitivities[elIdx] = -penal * Math.pow(dens, penal - 1) * strainEnergy;
            
            } else if (objectiveMode === 'stress') {
                // Min Stress Heuristic (Fully Stressed Design)
                // We fake the sensitivity to be proportional to -Stress.
                // The OC optimizer adds material where 'sensitivity' is most negative.
                // So, high stress -> highly negative sensitivity -> Add material.
                // We use the weighted stress from stress_global.
                sensitivities[elIdx] = -1.0 * stress_global[elIdx];
            }
        }
    }

    // 2. Filter Sensitivities
    const dc_filtered = new Float64Array(densities.length);
    for (let elx = 0; elx < NELX; elx++) {
        for (let ely = 0; ely < NELY; ely++) {
            const i = elx * NELY + ely;
            let weightSum = 0;
            let valSum = 0;
            const r_int = Math.floor(rmin);
            
            const x_min = Math.max(0, elx - r_int);
            const x_max = Math.min(NELX - 1, elx + r_int);
            const y_min = Math.max(0, ely - r_int);
            const y_max = Math.min(NELY - 1, ely + r_int);

            for (let nx = x_min; nx <= x_max; nx++) {
                for (let ny = y_min; ny <= y_max; ny++) {
                    const dist = Math.sqrt((elx - nx)**2 + (ely - ny)**2);
                    if (dist <= rmin) {
                        const weight = rmin - dist;
                        const j = nx * NELY + ny;
                        valSum += weight * densities[j] * sensitivities[j];
                        weightSum += weight;
                    }
                }
            }
            const safeX = Math.max(1e-6, densities[i]);
            dc_filtered[i] = valSum / (safeX * weightSum);
        }
    }
    
    // 3. Update Scheme (Optimality Criteria)
    let l1 = 0, l2 = 100000, move = 0.2;
    let xnew = new Float64Array(densities.length);

    // Standard OC Loop
    // For Stress, this acts as a stress-leveling algorithm
    while ((l2 - l1) / (l1 + l2) > 1e-3 && (l2-l1) > 1e-10) {
        let lmid = 0.5 * (l2 + l1);
        let currentVol = 0;
        
        for (let i = 0; i < densities.length; i++) {
            let val;
            if (passive[i] === 1) {
                val = 1.0;
            } else {
                let be = -dc_filtered[i] / lmid;
                // Protection against negative values in sqrt if math goes weird
                be = Math.max(1e-10, be); 
                val = densities[i] * Math.sqrt(be);
                val = Math.max(densities[i] - move, Math.min(densities[i] + move, val));
                val = Math.max(0.001, Math.min(1.0, val));
            }
            xnew[i] = val;
            currentVol += val;
        }

        if (currentVol > volfrac * NELX * NELY) l1 = lmid;
        else l2 = lmid;
    }

    let maxChange = 0;
    for(let i=0; i<densities.length; i++) {
        let diff = Math.abs(densities[i] - xnew[i]);
        if(diff > maxChange) maxChange = diff;
        densities[i] = xnew[i];
    }
    change = maxChange;
    iteration++;

    // UI Updates
    if(objectiveMode === 'compliance') {
        objDisplay.innerText = `C: ${compliance.toExponential(2)}`;
        overlayEl.innerHTML = `<span>Iter: ${iteration}</span><span>C: ${compliance.toExponential(2)}</span>`;
    } else {
        // Find max stress for display
        let ms = 0;
        for(let s of stress_global) if(s>ms) ms=s;
        objDisplay.innerText = `Max S: ${ms.toFixed(2)}`;
        overlayEl.innerHTML = `<span>Iter: ${iteration}</span><span>Max S: ${ms.toFixed(2)}</span>`;
    }
    statusEl.innerText = `Change: ${change.toFixed(4)} | Vol: ${(densities.reduce((a,b)=>a+b,0)/(NELX*NELY)).toFixed(2)}`;
}

// --- DRAWING ---

function getJetColor(val) {
    let r, g, b;
    const v = Math.max(0, Math.min(1, val));
    if (v < 0.25) {
        r = 0; g = 4 * v; b = 1;
    } else if (v < 0.5) {
        r = 0; g = 1; b = 1 - 4 * (v - 0.25);
    } else if (v < 0.75) {
        r = 4 * (v - 0.5); g = 1; b = 0;
    } else {
        r = 1; g = 1 - 4 * (v - 0.75); b = 0;
    }
    return `rgb(${Math.floor(r*255)},${Math.floor(g*255)},${Math.floor(b*255)})`;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const showGrid = document.getElementById('showGrid').checked;

    let maxS = 0;
    let maxD = 0;
    if (viewMode === 'stress') {
        for(let v of stress_global) if(v>maxS) maxS = v;
        if(maxS === 0) maxS = 1;
    } else if (viewMode === 'disp') {
        for(let i=0; i<u_global.length/2; i++) {
            const dx = u_global[2*i];
            const dy = u_global[2*i+1];
            const d = Math.sqrt(dx*dx + dy*dy);
            if(d>maxD) maxD = d;
        }
        if(maxD === 0) maxD = 1;
    }

    for (let elx = 0; elx < NELX; elx++) {
        for (let ely = 0; ely < NELY; ely++) {
            const idx = elx * NELY + ely;
            
            if (viewMode === 'density') {
                if (passive[idx] === 1) {
                    ctx.fillStyle = "#10b981";
                } else {
                    const density = densities[idx];
                    const gray = Math.floor(255 * (1 - density));
                    ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                }
            } else if (viewMode === 'stress') {
                if (densities[idx] < 0.1) ctx.fillStyle = "#fff";
                else ctx.fillStyle = getJetColor(stress_global[idx] / maxS);
            } else if (viewMode === 'disp') {
                const n = (NELY + 1) * elx + ely;
                const dx = u_global[2*n];
                const dy = u_global[2*n+1];
                const d = Math.sqrt(dx*dx + dy*dy);
                if (densities[idx] < 0.1) ctx.fillStyle = "#fff";
                else ctx.fillStyle = getJetColor(d / maxD);
            }

            const x = elx * SCALE;
            const y = ely * SCALE;
            ctx.fillRect(x, y, SCALE, SCALE);

            if (showGrid) {
                ctx.strokeStyle = "rgba(100, 100, 100, 0.1)";
                ctx.lineWidth = 0.5;
                ctx.strokeRect(x, y, SCALE, SCALE);
            }
        }
    }

    // Supports
    ctx.fillStyle = "#3b82f6";
    const drawnNodes = new Set();
    for (let dof of fixedDofs) {
        const node = Math.floor(dof / 2);
        if (drawnNodes.has(node)) continue;
        drawnNodes.add(node);
        const nx = Math.floor(node / (NELY + 1));
        const ny = node % (NELY + 1);
        ctx.beginPath();
        ctx.arc(nx * SCALE, ny * SCALE, 3, 0, 2*Math.PI);
        ctx.fill();
    }

    // Forces
    ctx.fillStyle = "#ef4444";
    ctx.strokeStyle = "#ef4444";
    ctx.lineWidth = 2;
    for (let [dof, val] of forceDofs) {
        const node = Math.floor(dof / 2);
        const dir = dof % 2; 
        const nx = Math.floor(node / (NELY + 1));
        const ny = node % (NELY + 1);
        const px = nx * SCALE;
        const py = ny * SCALE;

        ctx.beginPath();
        ctx.moveTo(px, py);
        if (dir === 0) {
            const len = val * 20;
            ctx.lineTo(px + len, py);
            ctx.stroke();
            ctx.beginPath(); ctx.arc(px + len, py, 2, 0, 2*Math.PI); ctx.fill();
        } else {
            const len = val * 20;
            ctx.lineTo(px, py + len);
            ctx.stroke();
            ctx.beginPath(); ctx.arc(px, py + len, 2, 0, 2*Math.PI); ctx.fill();
        }
    }
}

// --- EVENTS ---

let isDragging = false;

document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.onclick = () => {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        activeTool = btn.dataset.tool;
    };
});

document.getElementById('viewMode').onchange = (e) => {
    viewMode = e.target.value;
    if (viewMode === 'stress' || viewMode === 'disp') {
        legendEl.style.display = 'block';
        if (!running && u_global[0] === 0 && u_global.length > 0) optimizeStep();
    } else {
        legendEl.style.display = 'none';
    }
    draw();
};

document.getElementById('objMode').onchange = (e) => {
    objectiveMode = e.target.value;
    // Reset change to trigger animation if running
    change = 1.0;
    statusEl.innerText = `Objective changed to: ${e.target.options[e.target.selectedIndex].text}`;
};

document.getElementById('showGrid').onchange = draw;

function handleInteraction(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const nx = Math.round(mx / SCALE);
    const ny = Math.round(my / SCALE);
    const ex = Math.floor(mx / SCALE);
    const ey = Math.floor(my / SCALE);

    const inNodeBounds = nx >= 0 && nx <= NELX && ny >= 0 && ny <= NELY;
    const inElemBounds = ex >= 0 && ex < NELX && ey >= 0 && ey < NELY;

    if (activeTool === 'force' && inNodeBounds && e.type === 'mousedown') {
        const nodeIdx = nx * (NELY + 1) + ny;
        const mag = parseFloat(document.getElementById('forceMag').value);
        forceDofs.set(2 * nodeIdx + 1, mag);
        change = 1.0;
    } else if (activeTool === 'fix' && inNodeBounds) {
        const nodeIdx = nx * (NELY + 1) + ny;
        fixedDofs.add(2 * nodeIdx);
        fixedDofs.add(2 * nodeIdx + 1);
        change = 1.0;
    } else if (activeTool === 'passive_solid' && inElemBounds) {
        passive[ex * NELY + ey] = 1;
        densities[ex * NELY + ey] = 1.0;
    } else if (activeTool === 'eraser') {
        if (inNodeBounds) {
            const n = nx * (NELY + 1) + ny;
            fixedDofs.delete(2*n); fixedDofs.delete(2*n+1);
            forceDofs.delete(2*n); forceDofs.delete(2*n+1);
        }
        if (inElemBounds) passive[ex * NELY + ey] = 0;
        change = 1.0;
    }
    draw();
}

canvas.addEventListener('mousedown', e => { isDragging = true; handleInteraction(e); });
canvas.addEventListener('mousemove', e => { if(isDragging) handleInteraction(e); });
canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mouseleave', () => isDragging = false);

function loop() {
    if (!running) return;
    optimizeStep();
    draw();
    if (change > 0.002) requestAnimationFrame(loop);
    else {
        running = false;
        document.getElementById('btnToggle').innerText = "Converged";
    }
}

document.getElementById('btnToggle').onclick = () => {
    running = !running;
    document.getElementById('btnToggle').innerText = running ? "Pause" : "Resume";
    if (running) loop();
};

document.getElementById('btnStep').onclick = () => {
    running = false;
    document.getElementById('btnToggle').innerText = "Resume";
    optimizeStep();
    draw();
};

document.getElementById('btnReset').onclick = () => {
    running = false;
    document.getElementById('btnToggle').innerText = "Start";
    densities.fill(volfrac);
    for(let i=0; i<passive.length; i++) if(passive[i]) densities[i]=1;
    iteration = 0; change = 1.0;
    draw();
};

document.getElementById('btnClearBC').onclick = () => {
    fixedDofs.clear(); forceDofs.clear(); passive.fill(0); densities.fill(volfrac);
    draw();
};

document.getElementById('volFrac').oninput = e => document.getElementById('volVal').innerText = e.target.value;
document.getElementById('forceMag').oninput = e => document.getElementById('loadVal').innerText = e.target.value;
document.getElementById('rmin').oninput = e => document.getElementById('filterVal').innerText = e.target.value;

canvas.addEventListener('contextmenu', e => e.preventDefault());

init();

})();
</script>
</body>
</html>